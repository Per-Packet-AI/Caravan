# *************************************************************************
#
# Copyright 2024 Qizheng Zhang (Stanford University),
#                Ali Imran (Purdue University),
#                Enkeleda Bardhi (Sapienza University of Rome),
#                Tushar Swamy (Unaffiliated),
#                Nathan Zhang (Stanford University),
#                Muhammad Shahbaz (Purdue University),
#                Kunle Olukotun (Stanford University)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# *************************************************************************

import sys
import copy
import logging

from models.mlp import *
from labeler.heuristics import *
from utils.label import *


class Labeler:
    def __init__(self):
        self.source = None


    def label(self):

        return None


class DNNLabeler(Labeler):
    def __init__(self, model_class, model_path, device):
        
        self.my_dnn_class = globals()[model_class]
        self.my_dnn = self.my_dnn_class().to(device)
        self.my_dnn.load_state_dict(torch.load(model_path))


    def label(self, features):

        _, my_label = self.my_dnn.run_inference(features)

        return my_label


class DeviceListLabeler(Labeler):
    def __init__(self, device_list_path, device):
        
        self.device_list_path = device_list_path


    def label(self, features, generated_labels):
        
        return generated_labels


    def classify(self, generated_labels):
        classify_results = copy.deepcopy(generated_labels).cuda()
        guesses = torch.randint(1, 7, (generated_labels.shape[0],)).cuda()
        classify_results = classify_results * (classify_results != -1) + \
            (classify_results == -1) * guesses
        return classify_results


class LMLabeler(Labeler):

    def __init__(self, model_name, api_key, application_type, system_prompt=[]):
        
        self.model_name = model_name
        self.api_key = api_key
        self.application_type = application_type
        self.price_incurred = 0.0
        self.system_prompt = system_prompt
        self.message = []

    def initialize_assistant(self, initial_prompt=None):

        assert len(self.message) == 0
        if self.application_type == "intrusion_detection":
            system_prompt = {
                                "role": "system",
                                # "content": "You are an expert in network security. The user is now labeling a network intrusion detection dataset, and he wants to assign a binary label (benign or malicious) to each traffic flow in the dataset based on each flow's input features. He'll give you a few labeled flows for reference, and you will help him label another few unlabeled flows. Feel free to use your own expertise and the information the user gives you. These are the features of the input flows (generated by CICFlowMeter): flow iat min,flow iat max,flow iat mean,packet length min,packet length max,packet length mean,total packet length,number of packets,syn flag count,ack flag count,psh flag count,fin flag count,rst flag count,ece flag count,flow duration,dst port."
                                "content": "You are an expert in network security. The user is now labeling a network intrusion detection dataset, and he wants to assign a binary label (benign or malicious) to each traffic flow in the dataset based on each flow's input features. He'll give you a few labeled flows for reference, and you will help him label another few unlabeled flows. Feel free to use your own expertise and the information the user gives you. These are the features of the input flows (provided by UNSW-NB15 dataset) and meanings of the features: dur(Record total duration),proto(Transaction protocol, which will be categorized),sbytes(Source to destination transaction bytes),dbytes(Destination to source transaction bytes),sttl(Source to destination time to live value),dttl(Destination to source time to live value),sload(Source bits per second),dload(Destination bits per second),spkts(Source to destination packet count),dpkts(Destination to source packet count),smean(Mean of the packet size transmitted by the src),dmean(Mean of the packet size transmitted by the dst),sinpkt(Source interpacket arrival time (mSec)),dinpkt(Destination interpacket arrival time (mSec)),tcprtt(TCP connection setup round-trip time),synack(TCP connection setup time, the time between the SYN and the SYN_ACK packets),ackdat(TCP connection setup time, the time between the SYN_ACK and the ACK packets),ct_src_ltm(No. of connections of the same source address in 100 connections according to the last time),ct_dst_ltm(No. of connections of the same destination address in 100 connections according to the last time),ct_dst_src_ltm(No of connections of the same source and the destination address in 100 connections according to the last time).",
                            }
            self.message.append(system_prompt)
            if not self.system_prompt:
                self.system_prompt.append(system_prompt)

            # few shot prompt for DoS GoldenEye and DoS Slowloris
            # few_shot_prompt = {
            #     "role": "user",
            #     "content": "To begin with, here are some labeled flows. The last field is the binary label (0 for benign and 1 for malicious): (1) 8.0, 5003400.0, 715190.0, 0.0, 972.0, 166.78, 1501.0, 8.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 5006300.0, 80.0, 1.0 (2) 2.0, 2.0, 2.0, 0.0, 8.0, 5.3333, 8.0, 2.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 2.0, 80.0, 1.0â€‹ (3) 31.0, 31.0, 31.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 31.0, 63594.0, 0.0 (4) 20.0, 203.0, 127.0, 0.0, 46.0, 15.4, 77.0, 4.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 381.0, 443.0, 0.0 (5) 27.0, 267.0, 134.17, 0.0, 488.0, 81.125, 649.0, 7.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 805.0, 80.0, 0.0 (6) 3021400.0, 3021400.0, 3021400.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 3021400.0, 30303.0, 0.0 (7) 2.0, 53248000.0, 6681900.0, 0.0, 230.0, 140.56, 2530.0, 17.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 106910000.0, 80.0, 1.0 (8) 107.0, 107.0, 107.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 107.0, 51454.0, 0.0 (9) 5.0, 5001400.0, 714860.0, 0.0, 972.0, 138.44, 1246.0, 8.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 5004000.0, 80.0, 1.0 (10) 7.0, 6950400.0, 1707800.0, 0.0, 662.0, 130.78, 1177.0, 8.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 11955000.0, 80.0, 1.0. Next, I will give you some unlabeled flows for labeling. You are expected to come up with a label for each flow based on what you learn from the benign flows above and your expertise in networking and security.",
            # }
            # self.message.append(few_shot_prompt)

            # few shot prompt for (1) DoS GoldenEye/Slowloris (2) FTP/SSH BruteForce (3) DDoS1 (4) DDoS2 (5) Bot
            # few_shot_prompt = {
            #     "role": "user",
            #     "content": "To begin with, here are some labeled flows for your reference later. The last field is the binary label (0 for benign and 1 for malicious): (1) 0.0,320.0,149.1666666667,0.0,242.0,48.75,390.0,7.0,0.0,0.0,1.0,0.0,0.0,0.0,895.0,80.0,0.0 (2) 59.0,265791.0,88642.0,0.0,0.0,0.0,0.0,4.0,0.0,0.0,1.0,0.0,0.0,0.0,265926.0,445.0,0.0 (3) 1023851.0,2015895.0,1519873.0,0.0,0.0,0.0,0.0,3.0,0.0,0.0,1.0,0.0,0.0,0.0,3039746.0,80.0,1.0 (4) 35.0,22879130.0,4824558.8,0.0,230.0,135.7647058824,2308.0,16.0,0.0,0.0,1.0,0.0,0.0,0.0,72368382.0,80.0,1.0 (5) 6.0,6.0,6.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,6.0,22.0,1.0 (6) 4.0,953182.0,176274.214285714,0.0,1173.0,170.5625,2729.0,15.0,0.0,0.0,1.0,0.0,0.0,0.0,2467839.0,3389.0,0.0 (7) 7.0,7.0,7.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,7.0,22.0,1.0 (8) 1.0,72574.0,34404.0,51.0,165.0,96.6,432.0,4.0,0.0,0.0,0.0,0.0,0.0,0.0,103212.0,53.0,0.0 (9) 11874.0,40328432.0,6943894.750000002,0.0,325.0,138.21428571428572,1903.0,13.0,1.0,1.0,0.0,0.0,0.0,0.0,83326737.0,443.0,0.0 (10) 20800000.0,20800000.0,20800000.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,20803090.0,80.0,1.0 (11) 11.0,5816306.0,833083.8571428573,0.0,231.0,36.44444444444444,328.0,8.0,0.0,0.0,1.0,0.0,1.0,1.0,5831587.0,80.0,0.0 (12) 1.0,1453229.0,242270.1667,0.0,964.0,123.0,984.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,1453621.0,80.0,1.0 (13) 10.0,6201.0,1146.333333,0.0,935.0,159.375,1275.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,6878.0,56031.0,0.0 (14) 3.0,573.0,186.3333333,0.0,935.0,153.25,1226.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,1118.0,54701.0,0.0 (15) 2592.0,2592.0,2592.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,2592.0,80.0,1.0 (16) 19156.0,19156.0,19156.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,19156.0,80.0,1.0 (17) 2.0,12405.0,2231.0,0.0,326.0,56.875,455.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,13386.0,8080.0,1.0 (18) 1358.0,1358.0,1358.0,45.0,134.0,74.66666667,179.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,1358.0,53.0,0.0 (19) 23.0,10675.0,1958.5,0.0,326.0,56.875,455.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,11751.0,8080.0,1.0 (20) 14.0,14.0,14.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,14.0,51102.0,0.0. Next, I will give you some unlabeled flows for labeling. Please let me know if you understand the requirement by answering yes or no.",
            #     # "content": "To begin with, here are some labeled flows for your reference later. The last field is the binary label (0 for benign and 1 for malicious): (1) 1.0,99999397.0,12501560.25,0.0,230.0,24.6,246.0,9.0,0.0,0.0,1.0,0.0,0.0,0.0,100012482.0,80.0,1.0 (2) 118761.0,118761.0,118761.0,38.0,209.0,95.0,247.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,118761.0,53.0,0.0 (3) 54200442.0,54200442.0,54200442.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,54200442.0,80.0,0.0 (4) 847.0,847.0,847.0,39.0,117.0,65.0,156.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,847.0,53.0,0.0 (5) 60013917.0,60013917.0,60013917.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,60013917.0,56898.0,0.0 (6) 5.0,71338.0,8382.4545454545,0.0,976.0,99.5,4577.0,45.0,0.0,0.0,1.0,0.0,0.0,0.0,368828.0,22.0,1.0 (7) 538.0,538.0,538.0,42.0,58.0,47.3333333333,100.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,538.0,53.0,0.0 (8) 418589.0,418589.0,418589.0,22.0,22.0,22.0,44.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,418589.0,5355.0,0.0 (9) 54860227.0,54860227.0,54860227.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,54860227.0,80.0,0.0 (10) 20800000.0,20800000.0,20800000.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,20835415.0,80.0,1.0 (11) 12.0,232.0,110.5,0.0,488.0,81.125,649.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,663.0,80.0,0.0 (12) 3.0,1831941.0,288274.125,0.0,1173.0,150.72222222222223,2713.0,17.0,0.0,0.0,1.0,0.0,0.0,0.0,4612386.0,3389.0,0.0 (13) 3.0,19849.0,3432.5,0.0,935.0,156.375,1251.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,20595.0,55746.0,0.0 (14) 7.0,31434.0,5332.5,0.0,935.0,159.25,1274.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,31995.0,64799.0,0.0 (15) 7261.0,7261.0,7261.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,7261.0,80.0,1.0 (16) 7.0,676.0,195.6666667,0.0,935.0,150.875,1207.0,7.0,0.0,0.0,1.0,0.0,1.0,1.0,1174.0,63603.0,0.0 (17) 3.0,2623362.0,354974.9524,0.0,1179.0,137.6086957,3165.0,22.0,0.0,0.0,1.0,0.0,1.0,1.0,7454474.0,3389.0,0.0 (18) 1635.0,1635.0,1635.0,34.0,79.0,49.0,113.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,1635.0,53.0,0.0 (19) 1.0,58200000.0,2010534.103,0.0,1460.0,578.0,17918.0,30.0,0.0,0.0,1.0,0.0,0.0,0.0,58305489.0,443.0,0.0 (20) 694.0,694.0,694.0,0.0,0.0,0.0,0.0,2.0,0.0,1.0,0.0,0.0,0.0,0.0,694.0,8080.0,1.0. Next, I will give you some unlabeled flows for labeling. Please let me know if you understand the requirement by answering yes or no.",
            # }
            few_shot_prompt = {
                "role": "user",
                "content": "To begin with, here are some labeled flows for your reference later. The last field is the binary label (0 for benign and 1 for malicious): (1) 0.000976,119.0,146.0,178.0,31.0,29.0,598360.6875,729508.1875,2.0,2.0,73.0,89.0,0.01,0.007,0.0,0.0,0.0,1.0,1.0,1.0,0.0 (2) 0.751156,113.0,608.0,646.0,254.0,252.0,5836.337891,6198.446289,10.0,10.0,61.0,65.0,83.461778,68.822555,0.138493,0.092118,0.046375,1.0,2.0,2.0,1.0 (3) 1.108163,113.0,608.0,646.0,254.0,252.0,3956.09668,4201.547852,10.0,10.0,61.0,65.0,123.129222,128.379625,0.121057,0.0805,0.040557,1.0,2.0,1.0,1.0 (4) 0.029765,114.0,2766.0,28906.0,31.0,29.0,726759.625,7600336.0,44.0,46.0,63.0,628.0,0.684674,0.649933,0.000624,0.000514,0.00011,4.0,2.0,1.0,0.0 (5) 3e-06,97.0,78.0,0.0,254.0,0.0,104000000.0,0.0,2.0,0.0,39.0,0.0,0.003,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0 (6) 0.00443,113.0,1036.0,2262.0,31.0,29.0,1715575.5,3745372.25,12.0,12.0,86.0,189.0,0.368909,0.341182,0.000824,0.000667,0.000157,5.0,3.0,2.0,0.0 (7) 0.064837,119.0,2304.0,2304.0,62.0,252.0,213211.5938,213211.5938,4.0,4.0,576.0,576.0,15.984,14.002667,0.0,0.0,0.0,4.0,4.0,4.0,1.0 (8) 0.160126,113.0,2158.0,1918.0,31.0,29.0,103368.5938,91078.27344,24.0,20.0,90.0,96.0,6.962,8.392053,0.000694,0.000549,0.000145,3.0,2.0,1.0,0.0 (9) 0.001024,119.0,130.0,162.0,31.0,29.0,507812.5,632812.5,2.0,2.0,65.0,81.0,0.008,0.006,0.0,0.0,0.0,1.0,7.0,2.0,0.0 (10) 6e-06,123.0,200.0,0.0,254.0,0.0,133333328.0,0.0,2.0,0.0,100.0,0.0,0.006,0.0,0.0,0.0,0.0,8.0,4.0,4.0,1.0 (11) 8e-06,78.0,200.0,0.0,254.0,0.0,100000000.0,0.0,2.0,0.0,100.0,0.0,0.008,0.0,0.0,0.0,0.0,3.0,2.0,5.0,1.0 (12) 11.049956,114.0,13038.0,531716.0,31.0,29.0,9398.045898,384052.9063,226.0,427.0,58.0,1245.0,49.109444,25.937743,0.000601,0.000473,0.000128,5.0,4.0,2.0,0.0 (13) 7e-06,119.0,264.0,0.0,60.0,0.0,150857136.0,0.0,2.0,0.0,132.0,0.0,0.007,0.0,0.0,0.0,0.0,27.0,27.0,27.0,0.0 (14) 5.447018,113.0,140142.0,698.0,254.0,252.0,203988.3125,961.994202,112.0,16.0,1251.0,44.0,48.247566,359.71,0.112129,0.051363,0.060766,2.0,1.0,1.0,1.0 (15) 0.00108,120.0,146.0,178.0,31.0,29.0,540740.75,659259.3125,2.0,2.0,73.0,89.0,0.011,0.011,0.0,0.0,0.0,5.0,1.0,1.0,0.0 (16) 0.032656,113.0,3406.0,37226.0,31.0,29.0,819696.25,8956884.0,56.0,56.0,61.0,665.0,0.598574,0.584745,0.000611,0.000492,0.000119,3.0,1.0,2.0,0.0 (17) 7e-06,98.0,200.0,0.0,254.0,0.0,114285712.0,0.0,2.0,0.0,100.0,0.0,0.007,0.0,0.0,0.0,0.0,4.0,3.0,7.0,1.0 (18) 3.155537,113.0,1252.0,1658.0,62.0,252.0,3042.271484,4013.263184,24.0,22.0,52.0,75.0,137.159436,145.049333,0.177542,0.109492,0.06805,2.0,1.0,28.0,1.0 (19) 1.348011,113.0,364.0,2604.0,62.0,252.0,1893.159546,13525.11231,8.0,8.0,46.0,326.0,192.573,178.248422,0.157394,0.09975,0.057644,3.0,3.0,4.0,1.0 (20) 0.007337,113.0,1920.0,4312.0,31.0,29.0,1998637.0,4506474.0,22.0,24.0,87.0,180.0,0.3485,0.295043,0.00066,0.000544,0.000116,1.0,3.0,1.0,0.0. Next, I will give you some unlabeled flows for labeling. Please let me know if you understand the requirement by answering yes or no.",
            }
            self.message.append(few_shot_prompt)

            # few_shot_response = {
            #     "role": "assistant",
            #     "content": "Certainly, let's proceed with labeling the unlabeled flows. Please provide the unlabeled flows for analysis."
            # }
            few_shot_response = {
                "role": "assistant",
                # "content": "Yes, I understand the requirement. Please go ahead and provide the unlabeled flows for labeling."
                "content": "Yes, I understand the requirement. Please provide the unlabeled flows for labeling."
            }
            self.message.append(few_shot_response)

    def feature_to_string(self, feature):
            feature_string = ""
            for k in range(feature.shape[0]):
                feature_string += f"{feature[k].item()},"
            feature_string = feature_string[:-1]
            return feature_string

    def form_prompt(self, features):

        prompt = "Please give me a label for each of these unlabeled flows. No explanation or analysis needed, label only; One flow on each line. Format for each line: (flow number) label. "

        for flow_index in range(features.shape[0]):
            prompt += f"({flow_index+1}) "
            prompt += self.feature_to_string(features[flow_index])
            prompt += " "

        return prompt

    def compute_price(self, usage):

        prompt_price = 0.0
        completion_price = 0.0
        if self.model_name == "gpt-4-1106-preview":
            prompt_price = 0.01
            completion_price = 0.03
        elif self.model_name == "gpt-4-32k-0613":
            prompt_price = 0.06
            completion_price = 0.12
        elif "3.5" in self.model_name:
            prompt_price = 0.001
            completion_price = 0.002
            
        return usage["prompt_tokens"] / 1000 * prompt_price +  \
               usage["completion_tokens"] / 1000 * completion_price

    def api_call_label(self, prompt, temp=0.05, max_tokens=4096):

        import openai
        openai.util.logger.setLevel(logging.WARNING)
        openai.api_key = self.api_key
        current_message = self.message + [{
                                "role": "user",
                                "content": prompt
                            }]
        print("before openai.ChatCompletion.create")
        response = openai.ChatCompletion.create(
            model=self.model_name,
            messages=current_message,
            temperature=temp,
            max_tokens=max_tokens,
            frequency_penalty=0.0
        )
        print("after openai.ChatCompletion.create")
        openai.api_key = None
        return response["choices"][0]["message"]["content"], \
               response["usage"]["total_tokens"], \
               self.compute_price(response["usage"])

    def parse_api_response_label(self, response):
        
        labels = []
        unparsed_labels = response.split("\n")
        for unparsed_label in unparsed_labels:
            if "(" not in unparsed_label:
                continue
            labels.append(float(unparsed_label.split(" ")[1]))
        # update self.message here if necessary
        return labels

    def api_call_rule(self, prompt, temp=0.05, max_tokens=4096):

        import openai
        openai.util.logger.setLevel(logging.WARNING)
        openai.api_key = self.api_key
        current_message = self.system_prompt + [{
                                "role": "user",
                                "content": prompt
                            }]
        print("before openai.ChatCompletion.create")
        response = openai.ChatCompletion.create(
            model=self.model_name,
            messages=current_message,
            temperature=temp,
            max_tokens=max_tokens,
            frequency_penalty=0.0
        )
        print("after openai.ChatCompletion.create")
        openai.api_key = None
        return response["choices"][0]["message"]["content"], \
               response["usage"]["total_tokens"], \
               self.compute_price(response["usage"])

    def parse_api_response_rule(self, response):
        my_rules_function = response.split("```")[1]
        my_rules_function_executable = my_rules_function.split("python\n")[1]
        return my_rules_function_executable

    def compute_rules_function(self, features):
        # form the prompt for rule generation
        prompt = "To begin with, here are some labeled flows for your reference later. The last field is the binary label (0 for benign and 1 for malicious): "
        for flow_index in range(features.shape[0]):
            prompt += f"({flow_index+1}) "
            prompt += self.feature_to_string(features[flow_index])
            prompt += " "
        rule_instruction_string = ". Based on these labeled flows, can you do some analysis and help me come up with some rules or heuristics (in the form of a python function) to determine if an unlabeled flow is benign or not? Make sure that in the python function, you label a flow as malicious only when you are very confident. Name the function label_flow_with_rule_cache(), and pass it in a format that can be executed by exec()."
        prompt += rule_instruction_string
        # get response through the api
        api_response, tokens, price = self.api_call_rule(prompt)
        my_rules_function_executable = self.parse_api_response_rule(api_response)
        return my_rules_function_executable, tokens, price

    def label(self, features):
        
        print("before form_prompt")
        prompt = self.form_prompt(features)
        print("before api_call_label")
        api_response, tokens, price = self.api_call_label(prompt)
        self.price_incurred += price
        print("before parse_api_response_label")
        try:
            labels = self.parse_api_response_label(api_response)
            return labels, api_response, tokens, price
        except:
            print("problem in prompt parsing")
            return None, api_response, 0.0, 0.0


class FlowLabeler(Labeler):
    def __init__(self, heuristics_function):
        super().__init__()
        self.granularity = "flow"
        self.heuristics_function = heuristics_function


    def label(self, raw_features):
        if self.heuristics_function and isinstance(self.heuristics_function, str):
            my_labels = globals()[self.heuristics_function](raw_features)

        elif self.heuristics_function and isinstance(self.heuristics_function, list):
            my_labels = None
            # resolve conflicts and aggregate labels
            for heuristics in self.heuristics_function:
                current_labels = globals()[heuristics](raw_features)
                if my_labels is None:
                    my_labels = current_labels
                else:
                    my_labels = aggregate_labels_simple(my_labels, current_labels)

        else:
            my_labels = None

        return my_labels
    

class PacketLabeler(Labeler):
    def __init__(self):
        super().__init__()
        self.granularity = "packet"


    def label(self, flows):

        return None